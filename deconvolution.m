function varargout = deconvolution(varargin)
%Deconvolution code
%Loading the data via the "file" menu: file -> load, 3 separate *.txt files
%with an information on the time, input and output signal. The time vector 
%could be generated by setting the initial time and the step, marking the 
%checkbox with the respective name. 
%
%All parameters of calculation set under "edit" submenu, edit -> parameters
%opening window for the entering a start value of standard deviation of
%epistemic error, slope of linear variogram, length of transfer function,
%type of estimation and number of realisations.
%
%The input/output and time properties could be also set under "edit" submenu 
%and including time units of the time vector, which will be converted into days
%after the calculation starts, time format of the time vector(for correct 
%visualisation): MATLAB time - time in days, considering as first point 1 Jan 00, 
%UNIX time 01 Jan 1970, EXCEL time 01 Jan 1900. The same menu includes
%check for initial concentration value (equal or not equal to zero, the
%case of artificial and natural tracer respectively) and the possibility of the
%substraction of a mean.
%
%The type of estimation: smooth estimate, conditional realisations or 
%conditional realisations with estimate of a smoothness parameter set in
%edit -> options.
%
%It is possible to view initial input and output signal as soon as it is
%loaded, under view->input/output signal.
%
%After all the data is loaded and the parameters are set, the calculation 
%process could be started using the "calculate" submenu or the button 
%"calculate". The time of the start of the calculations, pathes of the 
%loaded files, initial parameters and information on the process of the 
%calculation are automaticaly written in the "log.log" ascii file, which 
%is generated in the same folder with the matlab project files


% Begin initialization code - DO NOT EDIT
gui_Singleton = 1;
gui_State = struct('gui_Name',       mfilename, ...
                   'gui_Singleton',  gui_Singleton, ...
                   'gui_OpeningFcn', @deconvolution_OpeningFcn, ...
                   'gui_OutputFcn',  @deconvolution_OutputFcn, ...
                   'gui_LayoutFcn',  [] , ...
                   'gui_Callback',   []);
if nargin && ischar(varargin{1})
    gui_State.gui_Callback = str2func(varargin{1});
end

if nargout
    [varargout{1:nargout}] = gui_mainfcn(gui_State, varargin{:});
else
    gui_mainfcn(gui_State, varargin{:});
end

     
% End initialization code - DO NOT EDIT

% --- Executes just before deconvolution is made visible.
function deconvolution_OpeningFcn(hObject, ~, handles, varargin)
% This function has no output args, see OutputFcn.
% hObject    handle to figure
% eventdata  reserved - to be defined in a future version of MATLAB
% handles    structure with handles and user data (see GUIDATA)
% varargin   command line arguments to deconvolution (see VARARGIN)
clc
defaultBackground = get(0,'defaultUicontrolBackgroundColor');
set(handles.figure1,'Color',defaultBackground );
set([handles.logfile_uipanel,handles.parameters_uipanel,handles.int_res_uipanel,handles.fin_res_uipanel,...
     handles.textoutafter,handles.texttransferafter,handles.texttransfer,handles.slope_lin_var_edit,...
     handles.length_tr_f_edit,handles.num_real_edit,handles.st_dev_ep_edit,handles.tp_est_edit,...
     handles.calculate_button,handles.stopbutton],'BackgroundColor',defaultBackground );
%% Setting default values
handles.timeformat='n';
handles.timeunits='d';
handles.IniConc=1;
handles.MeanInOut='S'; 
if exist('log.log','file')
     fid=fopen('log.log');
for i=1:10
k=fgetl(fid);
switch i
case 1,
     k=k; 
case 2,
     k=strrep(k, '\\', '\');
     if  (exist(k,'file'))
     handles.timepath=k;
     else
          handles.timepath='';
     end
case 3,
     k=strrep(k, '\\', '\');
     if  (exist(k,'file'))
     handles.inputpath=k;
     else
          handles.inputpath='';
     end
     
case 4,
     k=strrep(k, '\\', '\');
     if  (exist(k,'file'))
     handles.outputpath=k;
     else
          handles.outputpath='';
     end
case 5,
     if strmatch('Initial time', k);
     handles.initialtime=cell2mat(textscan(k,'Initial time %n'));
     else handles.initialtime=0;
     end
case 6,
     if strmatch('Time step', k);
     handles.timestep=cell2mat(textscan(k,'Time step %n'));
     else handles.timestep=0;
     end
case 7,
     if strmatch('Slope of linear variogram', k);
     handles.Theta=cell2mat(textscan(k,'Slope of linear variogram %n'));
     else handles.Theta=0;
     end
case 8,
     if strmatch('Length of transfer function', k);
     handles.TrFunLength=cell2mat(textscan(k,'Length of transfer function %n'));
     else handles.TrFunLength=0;
     end
case 9,
     if strmatch('Number of realisations', k);
     handles.Nreal=cell2mat(textscan(k,'Number of realisations %n'));
     else  handles.Nreal=0;
     end
case 10
     if strmatch('Standard deviation of epistemic error', k);
     handles.sigma=cell2mat(textscan(k,'Standard deviation of epistemic error %n'));
     else handles.sigma=0;
     end
end
end
fclose(fid);
set(handles.slope_lin_var_value_edit,'string',handles.Theta);
set(handles.length_tr_f_value_edit,'string',handles.TrFunLength);
set(handles.num_real_value_edit,'string',handles.Nreal);
set(handles.std_dev_ep_value_edit,'string',handles.sigma);
set(handles.type_est_value_edit,'string','Smooth estimate');
end     

guidata(hObject,handles);

% UIWAIT makes deconvolution wait for user response (see UIRESUME)
% uiwait(handles.figure1);


% --- Outputs from this function are returned to the command line.
function varargout = deconvolution_OutputFcn(~, eventdata, handles)
% varargout  cell array for returning output args (see VARARGOUT);
% hObject    handle to figure
% eventdata  reserved - to be defined in a future version of MATLAB
% handles    structure with handles and user data (see GUIDATA)

% Get default command line output from handles structure

% --------------------------------------------------------------------
function TrFuncSmoothSaveMenuItem_Callback(hObject, eventdata, handles)
% hObject    handle to TrFuncSmoothSaveMenuItem (see GCBO)
% eventdata  reserved - to be defined in a future version of MATLAB
% handles    structure with handles and user data (see GUIDATA)
if ~any(strcmp('TrFunc_uncert',fieldnames(handles)))
     handles.TrFunc_uncert=0;
end
currentFolder = pwd;
[filename,pathname] = uiputfile({'*.txt';'*.mat'},'Save transfer function');
[~,file,ext]=fileparts(filename);
cd(pathname);
if strcmp(ext,'.txt') 
     fid = fopen(filename,'w');
fprintf(fid,'%17s%17s%17s%17s\n','t','g(t)-uncert','g(t)','g(t)+uncert');
fid = fopen(filename,'a');
for i=[1:length(handles.TrFunc)]
fprintf(fid,'%14.3g %14.3g %14.3g  %14.3g\n',...
    handles.Time_out(i),...
    handles.TrFunc(i)-handles.TrFunc_uncert(i),...
    handles.TrFunc(i),...
    handles.TrFunc(i)+handles.TrFunc_uncert(i) );
end
fclose('all');
elseif strcmp(ext,'.mat') 
     t=handles.Time_out;
     TrFunc_ucert_l=handles.TrFunc-handles.TrFunc_uncert;
     TrFunc_ucert_u=handles.TrFunc+handles.TrFunc_uncert;
     TrFunc=handles.TrFunc;
     save(filename,'t','TrFunc','TrFunc_ucert_l','TrFunc_ucert_u');
end
cd(currentFolder);





% --------------------------------------------------------------------
function OpenTimesMenuItem_Callback(hObject, eventdata, handles)
% hObject    handle to OpenTimesMenuItem (see GCBO)
% eventdata  reserved - to be defined in a future version of MATLAB
% handles    structure with handles and user data (see GUIDATA)
%[FileName,PathName,FilterIndex] = uigetfile(FilterSpec,DialogTitle)
currentFolder=pwd;
[file,pathname] = uigetfile('*.txt');
cd(pathname);
if ~isequal(file, 0)
    handles.Time=load(file);
    handles.timepath=[pathname file];
    guidata(hObject,handles);
end
cd(currentFolder);


% --------------------------------------------------------------------
function OpenInpSigMenuItem_Callback(hObject, eventdata, handles)
% hObject    handle to OpenInpSigMenuItem (see GCBO)
% eventdata  reserved - to be defined in a future version of MATLAB
% handles    structure with handles and user data (see GUIDATA)
currentFolder=pwd;
[file,pathname] = uigetfile('*.txt');
cd(pathname);
if ~isequal(file, 0)
    handles.InpSig=load(file);
    handles.inputpath=[pathname file];
    guidata(hObject,handles)
end
cd(currentFolder);


% --------------------------------------------------------------------
function OpenOutSigMenuItem_Callback(hObject, eventdata, handles)
% hObject    handle to OpenOutSigMenuItem (see GCBO)
% eventdata  reserved - to be defined in a future version of MATLAB
% handles    structure with handles and user data (see GUIDATA)
currentFolder=pwd;
[file,pathname] = uigetfile('*.txt');
cd(pathname);
if ~isequal(file, 0)
    handles.OutSig=load(file);
    handles.outputpath=[pathname file];
    guidata(hObject,handles)
end
cd(currentFolder);


% --- Executes on button press in calculate_button.
function calculate_button_Callback(hObject, eventdata, handles)
% hObject    handle to calculate_button (see GCBO)
% eventdata  reserved - to be defined in a future version of MATLAB
% handles    structure with handles and user data (see GUIDATA)
clc
start=1;
cla(handles.axes1);
cla(handles.axes2);
cla(handles.axes3); 
legend(handles.axes3,'hide');
set(handles.texttransferafter, 'String','');
fclose('all');
stopflag = 0;
set(handles.StopMenuItem,'UserData',stopflag);
if ~any(strcmp('InpSig',fieldnames(handles))) || ~any(strcmp('OutSig',fieldnames(handles)))...
          || ~any(strcmp('Time',fieldnames(handles)))
    SpecifPathMenuItem_Callback(hObject, eventdata, handles)
    start=0;
end
if start==1
if ~any(strcmp('Theta',fieldnames(handles))) || ~any(strcmp('TrFunLength',fieldnames(handles)))...
          || ~any(strcmp('Nreal',fieldnames(handles)))
    ParametersMenuItem_Callback(hObject, eventdata, handles)
    start=0;
end  
end
if start==1
if ~any(strcmp('type_estimate',fieldnames(handles)))
     OptionsMenuItem_Callback(hObject, eventdata, handles);
     start=0;
end
end
if start==1
set(handles.slope_lin_var_value_edit,'string',handles.Theta);
set(handles.length_tr_f_value_edit,'string',handles.TrFunLength);
set(handles.num_real_value_edit,'string',handles.Nreal);
set(handles.std_dev_ep_value_edit,'string',handles.sigma);
rand('state',sum(100*clock));
%% Input 
% input signal
x=handles.InpSig;
% output signal
yext=handles.OutSig;
%Time
time=handles.Time;
%% Generate log-file
s=['Number of measurements '  num2str(length(handles.InpSig))];
add_line = char(datestr(now),handles.timepath,handles.inputpath,handles.outputpath,s);
       set(handles.logfile_listbox,'String',add_line) 
       fid=fopen('log.log','w');
       f=datestr(now);
       fprintf(fid,[f ' \r\n']);
       fclose(fid);
       fid=fopen('log.log','a');
       f=strrep(handles.timepath, '\', '\\');
       %f=sprintf('%s \r\n',handles.timepath)
       fprintf(fid,[f ' \r\n']);
       f=strrep(handles.inputpath, '\', '\\');
       %f=sprintf('%s \r\n',handles.inputpath)
       fprintf(fid,[f ' \r\n']);
       f=strrep(handles.outputpath, '\', '\\');
       %f=sprintf('%s \r\n',handles.outputpath)
       fprintf(fid,[f ' \r\n']);
       f=sprintf('Initial time %d \r\n',handles.initialtime);
       fprintf(fid,f);
       f=sprintf('Time step %d \r\n',handles.timestep);
       fprintf(fid,f);
       f=sprintf('Slope of linear variogram %d \r\n',handles.Theta);
       fprintf(fid,f);
       f=sprintf('Length of transfer function %d \r\n',handles.TrFunLength);
       fprintf(fid,f);
       f=sprintf('Number of realisations %d \r\n',handles.Nreal);
       fprintf(fid,f);
       f=sprintf('Standard deviation of epistemic error %d \r\n',handles.sigma);
       fprintf(fid,f);
       fclose('all');
%% Parameters
% slope of the linear variogram
theta=handles.Theta;
% standard deviation of epistemic error (initial guess) 0.973
sigma = handles.sigma;
% length of transfer-function vector
n_h=handles.TrFunLength;
% number of realizations
nreal=handles.Nreal;
x=x(1:size(yext,1));
%% changing time format

DateString = '01-01-1970';
formatIn = 'dd-mm-yyyy';
unix_timeformat=datenum(DateString,formatIn);
DateString = '01-01-1900';
excell_timeformat=datenum(DateString,formatIn);
switch handles.timeformat
case 'n',
     timeformat=0;                  %matlab time
case 'm',
     timeformat=0;                  %matlab time
case 'u',
     timeformat=unix_timeformat;    %unix time
case 'e',
     timeformat=excell_timeformat;  %excel time 
end

%% Changing time units
switch handles.timeunits
case 's',
     timeunits=24*60*60; %seconds
case 'm',
     timeunits=60*60;    %minutes
case 'h',
     timeunits=60;       %hours
case 'd',
     timeunits=1;        %days
end
time=time/timeunits-timeformat; %change into matlab time
time=time(1:length(yext));
theta_old=0;
%% consider only part where the response is complete
if handles.IniConc==1
y=yext(n_h:end);
t=time(n_h:end);
else 
y=yext;
t=time;
end
% substract mean
if strcmp(handles.MeanInOut,'S')
x=x-mean(x);
yext=yext-mean(y);
y=y-mean(y);
end
% time increment
dt=time(2)-time(1);
% construction of Jacobian (convolution matrix)
if handles.IniConc==1
   c=dt*x(n_h:end);
   r=dt*x(n_h:-1:1);
else
   c=dt*x;
   r=dt*zeros(1,n_h);
   r(1)=c(1);
end

J=toeplitz(c,r);
set(handles.axes3, 'NextPlot', 'replace');
%smooth estimate
 if strcmp(handles.type_estimate,'sm')
set(handles.num_real_value_edit,'string',0);
% construction of generalized covariance matrix
c=[n_h:-1:1]*theta*dt;
Q=toeplitz(c);
iQ=inv(Q);

% vector of indices
ii=[1:n_h]';

% initialization of constraints
hL=[]; % vector of entries affected by Lagrange multipliers
nL=0;  % number of Lagrange multipliers

iter=0;
set(handles.int_res_uipanel, 'Title', 'Smooth estimate')
while 1==1
    iter=iter+1;
    stopflag = get(handles.StopMenuItem,'UserData');
    if stopflag==1,   break,     end
    % construction of unconstrained matrix
    JRJ=J'*J/sigma^2;
    u=ones(n_h,1);
    umat=[JRJ+iQ,JRJ*u;u'*JRJ,u'*JRJ*u];
    urhs=[J'*y/sigma^2;u'*J'*y/sigma^2];
    % matrix related to the Lagrange multipliers
    Lmat=zeros(n_h+1,nL);
    for j=1:nL
        Lmat(hL(j),j)=1;
        Lmat(n_h+1,j)=1;
    end
    mat=[umat,Lmat;Lmat',zeros(nL)];
    rhs=[urhs;zeros(nL,1)];
    a=diag(mat);a(n_h+2:end)=1;
    warning off;imat=inv(diag(a.^-1)*mat)*diag(a.^-1);warning on;
    sol=imat*rhs;
    h=sol(1:n_h)+sol(n_h+1);
    h(hL)=0;
    nu=sol(n_h+2:end);
    sim=J*h;
    % estimation variance
    Qc_mix=imat*(mat-[[iQ;zeros(1,n_h)],zeros(n_h+1,1),Lmat;Lmat',zeros(nL,nL)])*imat;
    Qc=[eye(n_h) ones(n_h,1)]*Qc_mix(1:n_h+1,1:n_h+1)*[ones(1,n_h);eye(n_h)];
    estvar=diag(Qc);estvar(estvar<0)=0;
    eststd=sqrt(estvar);
    % statistics of residuals
    sigma=sqrt((y-sim)'*(y-sim)/(size(y,1)-n_h+nL-1));
    set(handles.std_dev_ep_value_edit,'string',sigma);
    event1=sprintf('iteration %i: sigma = %8.3g, number of Lagrange multipliers %i',[iter,sigma,nL]);
    all_lines=cellstr(get(handles.logfile_listbox,'String'));
    add_line = [all_lines;event1];
    set(handles.logfile_listbox,'String',add_line) 
    set(handles.logfile_listbox,'ListboxTop',length(add_line)-2) 
    fid=fopen('log.log','a');
    fprintf(fid,[event1 ' \r\n']);
       set(handles.textoutafter, 'String', sprintf('Output after iteration %i',iter));
     handle=plot(handles.axes1,time,yext,'-r',t,sim,'-k');
       set(handle(1),'markersize',2);
       set(handle(2),'linewidth',1.5);
       t_tick=linspace(t(1),t(end),6);
       set(handles.axes1,'XTick',t_tick);
       if     handles.timeformat~='n'
%       set(handles.axes1,'xticklabel',datestr(t_tick,'mmm-yyyy'));
       datetick(handles.axes1,'x');
       end
       legend(handles.axes1,'meas.','sim.');
       set(handles.textoutafter, 'String', sprintf('Output after iteration %i',iter));
       handle=plot(handles.axes2,[0:n_h-1]*dt,[h h-eststd h+eststd],'k');
       set(handle(2:end),'color','r')
       set(handles.texttransferafter, 'String', sprintf('Transfer function after iteration %i',iter));
       legend(handles.axes2,'h','h\pm\sigma')
       xlabel(handles.axes2,'\tau [d]');
       drawnow
       hLold=hL;
    % set of entries that need Lagrange multiplier
    hLadd=ii(h<0);
    % remove entries that don't need a Lagrange multiplier anymore
    hLrem=hL(nu>0);
    hL=hL(~ismember(hL,hLrem));
    hL=union(hL,hLadd);
    if (isempty(hL)), hL=1; elseif(hL(1)~=1), hL=[1;hL]; end
    nL=length(hL);
    if isempty(setdiff(hLold,hL)) && isempty(setdiff(hL,hLold)), break, end
end 
    t_h=dt*[0:n_h-1]';
    m0=sum(h)*dt;
    m1=sum(t_h.*h)*dt/m0;
    m2c=sum(t_h.^2.*h)*dt/m0-m1^2;
    mu=log(m1^2/sqrt(m2c+m1^2));
    s=sqrt(log((m2c+m1^2)/m1^2));
    set(handles.axes3, 'NextPlot', 'replace');
    hand=plot(handles.axes3,[0:n_h-1]*dt,[h h-eststd h+eststd],'k');
    set(hand(2:end),'color','r')
    set(hand,'linewidth',1.5);
    legend(handles.axes3,'h','h\pm\sigma')
    xlabel(handles.axes3,'\tau');
    event1=sprintf('m_0 = %0.3g mu_tau = %0.3g d sigma_tau = %0.3g d',[m0,m1,sqrt(m2c)]);
    all_lines=cellstr(get(handles.logfile_listbox,'String'));
    add_line = [all_lines;event1];
    set(handles.logfile_listbox,'String',add_line) 
    set(handles.logfile_listbox,'ListboxTop',length(add_line)-2) 
    fid=fopen('log.log','a');
    fprintf(fid,[event1 ' \r\n']);
     set(handles.textoutafter, 'String', sprintf('Output after iteration %i',iter));
       handle=plot(handles.axes1,time,yext,'-r',t,sim,'-k');
       set(handle(1),'markersize',2);
       set(handle(2),'linewidth',1.5);
       t_tick=linspace(t(1),t(end),6);
       set(handles.axes1,'XTick',t_tick);
       if     handles.timeformat~='n'
%       set(handles.axes1,'xticklabel',datestr(t_tick,'mmm-yyyy'));
       datetick(handles.axes1,'x');
       end
       legend(handles.axes1,'meas.','sim.');
       fclose('all');
       handles.Time_out=t_h;
       handles.TrFunc=h;
       handles.TrFunc_uncert=eststd;
       handles.output_time=t;
       handles.output_meas=yext;
       handles.output_sim=sim;
       guidata(hObject,handles);
       defaultBackground = get(0,'defaultUicontrolBackgroundColor');
set(handles.figure1,'Color',defaultBackground )
elseif strcmp(handles.type_estimate,'cr')
     %% type of estimation - conditional realisations
% construction of generalized covariance matrix (here time in hours)
set(handles.num_real_value_edit,'string',handles.Nreal);
c=[n_h:-1:1]*theta*dt;
Q=toeplitz(c);
C=chol(Q);
iQ=inv(Q);

% vector of indices
ii=[1:n_h]';

% Best estimate
% initialization of constraints
 hL=[];
 nL=0;
 iter=0;
 while 1==1
      stopflag = get(handles.StopMenuItem,'UserData');
    if stopflag==1,   break,     end
       iter=iter+1;
       % construction of unconstrained matrix
       JRJ=J'*J/sigma^2;
       u=ones(n_h,1);
       umat=[JRJ+iQ,JRJ*u;u'*JRJ,u'*JRJ*u];
       urhs=[J'*y/sigma^2;u'*J'*y/sigma^2];
       % matrix related to the Lagrange multipliers
       Lmat=zeros(n_h+1,nL);
       Lrhs=zeros(nL,1);
       for j=1:nL
           Lmat(hL(j),j)=1;
           Lmat(n_h+1,j)=1;
           Lrhs(j)=0;
       end
       mat=[umat,Lmat;Lmat',zeros(nL)];
       rhs=[urhs;Lrhs];
       a=diag(mat);a(n_h+2:end)=1;
       warning off;imat=inv(diag(a.^-1)*mat)*diag(a.^-1);warning on;
       sol=imat*rhs;
       h_be=sol(1:n_h)+sol(n_h+1);
       h_be(hL)=0;
       nu=sol(n_h+2:end);
       sim=J*h_be;
       % estimation variance
    Qc_mix=imat*(mat-[[iQ;zeros(1,n_h)],zeros(n_h+1,1),Lmat;Lmat',zeros(nL,nL)])*imat;
    Qc=[eye(n_h) ones(n_h,1)]*Qc_mix(1:n_h+1,1:n_h+1)*[ones(1,n_h);eye(n_h)];
    estvar=diag(Qc);estvar(estvar<0)=0;
    eststd=sqrt(estvar);
    handles.TrFunc_uncert=eststd;
       sigma=sqrt((y-sim)'*(y-sim)/(length(y)-n_h+nL-1));
        event1=sprintf(['iteration %i: sigma = %8.3g, number of Lagrange ' ...
                     'multipliers %i'],[iter,sigma,nL]);
       all_lines=cellstr(get(handles.logfile_listbox,'String'));
       add_line = [all_lines;event1];
       set(handles.logfile_listbox,'String',add_line) 
       set(handles.logfile_listbox,'ListboxTop',length(add_line)-2) 
       set(handles.std_dev_ep_value_edit,'string',sigma);
       fid=fopen('log.log','a');
       fprintf(fid,[event1 ' \r\n']);
       fclose(fid);
       hLold=hL;
       % set of entries that need Lagrange multiplier
       hLadd=ii(h_be<0);
       % remove entries that don't need a Lagrange multiplier anymore
       hLrem=hL(nu>0);
       hL=hL(~ismember(hL,hLrem));
       hL=union(hL,hLadd);
       if (isempty(hL)), hL=1; elseif(hL(1)~=1), hL=[1;hL]; end
       nL=length(hL);
       if isempty(setdiff(hLold,hL)) && isempty(setdiff(hL,hLold)), break, end
end    

% initialize sum of h and sum of h squared
h_all  = zeros(n_h,nreal);

%figure(1);clf;
% loop over all realizations
for ireal=1:nreal
      stopflag = get(handles.StopMenuItem,'UserData');
     if stopflag==1,   break,     end
    % unconditional realiuzation
    h_uc=C'*randn(n_h,1);
    % measurement error
    me = sigma*randn(size(y));
    % initialization of constraints
    hL=[];
    nL=0;
    iter=0;
    while 1==1
         stopflag = get(handles.StopMenuItem,'UserData');
    if stopflag==1,   break,     end
        iter=iter+1;
        % construction of unconstrained matrix
        JRJ=J'*J/sigma^2;
        u=ones(n_h,1);
        umat=[JRJ+iQ,JRJ*u;u'*JRJ,u'*JRJ*u];
        urhs=[J'*(y+me)/sigma^2-JRJ*h_uc;u'*J'*(y+me)/sigma^2-u'*JRJ*h_uc];
        % matrix related to the Lagrange multipliers
        Lmat=zeros(n_h+1,nL);
        Lrhs=zeros(nL,1);
        for j=1:nL
            Lmat(hL(j),j)=1;
            Lmat(n_h+1,j)=1;
            Lrhs(j)=-h_uc(hL(j));
        end
        mat=[umat,Lmat;Lmat',zeros(nL)];
        rhs=[urhs;Lrhs];
        a=diag(mat);a(n_h+2:end)=1;
        warning off;imat=inv(diag(a.^-1)*mat)*diag(a.^-1);warning on;
        sol=imat*rhs;
        h=sol(1:n_h)+sol(n_h+1)+h_uc;
        h(hL)=0;
        nu=sol(n_h+2:end);
        sim=J*h;
        event1=sprintf('iteration %i: number of Lagrange multipliers %i',[iter,nL]);
       all_lines=cellstr(get(handles.logfile_listbox,'String'));
       add_line = [all_lines;event1];
       set(handles.logfile_listbox,'String',add_line) 
       set(handles.logfile_listbox,'ListboxTop',length(add_line)-2) 
       fid=fopen('log.log','a');
       fprintf(fid,[event1 ' \r\n']);
       fclose(fid);
       set(handles.int_res_uipanel, 'Title', sprintf('Realization %i',ireal))
       handle=plot(handles.axes1,t,y+me,'-r',t,sim,'-k');
       set(handle(1),'markersize',2);
       t_tick=linspace(t(1),t(end),6);
       set(handles.axes1,'XTick',t_tick);
       if     handles.timeformat~='n'
%        set(handles.axes1,'xticklabel',datestr(t_tick,'mmm-yyyy'));
       datetick(handles.axes1,'x');
       end
       legend(handles.axes1,'meas.','sim.');
       set(handles.textoutafter, 'String', sprintf('Output after iteration %i',iter));
       plot(handles.axes2,[0:n_h-1]*dt,h,'k');
       set(handles.texttransferafter, 'String', sprintf('Transfer function after iteration %i',iter));
       xlabel(handles.axes2,'\tau [d]');
       drawnow
        hLold=hL;
        % set of entries that need Lagrange multiplier
        hLadd=ii(h<0);
        % remove entries that don't need a Lagrange multiplier anymore
        hLrem=hL(nu>0);
        hL=hL(~ismember(hL,hLrem));
        hL=union(hL,hLadd);
        if (isempty(hL)), hL=1; elseif(hL(1)~=1), hL=[1;hL]; end
        nL=length(hL);
        if isempty(setdiff(hLold,hL)) && isempty(setdiff(hL,hLold)), break, end
    end    
    % plot realization
    t_h=dt*[0:n_h-1]';
    h_all(:,ireal) = h;
    set(handles.axes3, 'NextPlot', 'replace');
    hand=plot(handles.axes3,t_h,mean(h_all(:,1:ireal),2),'r');
    set(hand,'linewidth',1.5);
    xlabel(handles.axes3,'\tau [d]');
    set(handles.axes3, 'NextPlot', 'add');
    plot(handles.axes3,t_h,prctile(h_all(:,1:ireal),[10 90],2),'b');
    plot(handles.axes3,t_h,[min(h_all(:,1:ireal),[],2),max(h_all(:,1:ireal),[],2)],'b:');
    legend(handles.axes3,'mean','10%','90%','min','max')
end
h=h_be;
handles.TrFunc=h_be; %save transfer function b.e.
guidata(hObject,handles);
handles.Time_out=t_h; %save time
guidata(hObject,handles);
handles.TrFunc_mean=mean(h_all(:,1:nreal),2);
handles.TrFunc_all=h_all;
handles.TrFunc_quantiles=prctile(h_all,10,2);
handles.TrFunc_min=min(h_all,[],2);
handles.TrFunc_max=max(h_all,[],2);
guidata(hObject,handles);
% plot final results
set(handles.axes3, 'NextPlot', 'replace');
hand=plot(handles.axes3,t_h,mean(h_all,2),'r');
xlabel(handles.axes3,'\tau [d]');
ylabel(handles.axes3,'g [1/d]');
set(handles.axes3, 'NextPlot', 'add');
plot(handles.axes3,t_h,prctile(h_all,10,2),'b');
plot(handles.axes3,t_h,min(h_all,[],2),'c');
cross=plot(handles.axes3,t_h(5:10:end),h(5:10:end),'rx');set(cross,'markersize',4);
plot(handles.axes3,t_h,prctile(h_all,90,2),'b');
plot(handles.axes3,t_h,max(h_all,[],2),'c');
legend(handles.axes3,'conditional mean','10%, 90%','min, max','best estimate');
defaultBackground = get(0,'defaultUicontrolBackgroundColor');
set(handles.figure1,'Color',defaultBackground )
elseif strcmp(handles.type_estimate,'cr+')
     set(handles.num_real_value_edit,'string',handles.Nreal);
while(abs(theta_old-theta)/theta>0.01)
% construction of generalized covariance matrix (here time in hours)
stopflag = get(handles.StopMenuItem,'UserData');
    if stopflag==1,   break,     end
c=[n_h:-1:1]*theta*dt;
Q=toeplitz(c);
C=chol(Q);
iQ=inv(Q);

% vector of indices
ii=[1:n_h]';

% Best estimate
% initialization of constraints
 hL=[];
 nL=0;
 iter=0;
 while 1==1
      stopflag = get(handles.StopMenuItem,'UserData');
    if stopflag==1,   break,     end
       iter=iter+1;
       % construction of unconstrained matrix
       JRJ=J'*J/sigma^2;
       u=ones(n_h,1);
       umat=[JRJ+iQ,JRJ*u;u'*JRJ,u'*JRJ*u];
       urhs=[J'*y/sigma^2;u'*J'*y/sigma^2];
       % matrix related to the Lagrange multipliers
       Lmat=zeros(n_h+1,nL);
       Lrhs=zeros(nL,1);
       for j=1:nL
           Lmat(hL(j),j)=1;
           Lmat(n_h+1,j)=1;
           Lrhs(j)=0;
       end
       mat=[umat,Lmat;Lmat',zeros(nL)];
       rhs=[urhs;Lrhs];
       a=diag(mat);a(n_h+2:end)=1;
       warning off;imat=inv(diag(a.^-1)*mat)*diag(a.^-1);warning on;
       sol=imat*rhs;
       h_be=sol(1:n_h)+sol(n_h+1);
       h_be(hL)=0;
       nu=sol(n_h+2:end);
       sim=J*h_be;
       % estimation variance
    Qc_mix=imat*(mat-[[iQ;zeros(1,n_h)],zeros(n_h+1,1),Lmat;Lmat',zeros(nL,nL)])*imat;
    Qc=[eye(n_h) ones(n_h,1)]*Qc_mix(1:n_h+1,1:n_h+1)*[ones(1,n_h);eye(n_h)];
    estvar=diag(Qc);estvar(estvar<0)=0;
    eststd=sqrt(estvar);
    handles.TrFunc_uncert=eststd;
       sigma=sqrt((y-sim)'*(y-sim)/(length(y)-n_h+nL-1));
        event1=sprintf(['iteration %i: sigma = %8.3g, number of Lagrange ' ...
                     'multipliers %i'],[iter,sigma,nL]);
       all_lines=cellstr(get(handles.logfile_listbox,'String'));
       add_line = [all_lines;event1];
       set(handles.logfile_listbox,'String',add_line) 
       set(handles.logfile_listbox,'ListboxTop',length(add_line)-2) 
       set(handles.std_dev_ep_value_edit,'string',sigma);
       fid=fopen('log.log','a');
       fprintf(fid,[event1 ' \r\n']);
       fclose(fid);
       hLold=hL;
       % set of entries that need Lagrange multiplier
       hLadd=ii(h_be<0);
       % remove entries that don't need a Lagrange multiplier anymore
       hLrem=hL(nu>0);
       hL=hL(~ismember(hL,hLrem));
       hL=union(hL,hLadd);
       if (isempty(hL)), hL=1; elseif(hL(1)~=1), hL=[1;hL]; end
       nL=length(hL);
       if isempty(setdiff(hLold,hL)) && isempty(setdiff(hL,hLold)), break, end
end    

% initialize sum of h and sum of h squared
h_all  = zeros(n_h,nreal);

%figure(1);clf;
% loop over all realizations
for ireal=1:nreal
     stopflag = get(handles.StopMenuItem,'UserData');
    if stopflag==1,   break,     end
    % unconditional realization
    h_uc=C'*randn(n_h,1);
    % measurement error
    me = sigma*randn(size(y));
    % initialization of constraints
    hL=[];
    nL=0;
    iter=0;
    while 1==1
         stopflag = get(handles.StopMenuItem,'UserData');
    if stopflag==1,   break,     end
        iter=iter+1;
        % construction of unconstrained matrix
        JRJ=J'*J/sigma^2;
        u=ones(n_h,1);
        umat=[JRJ+iQ,JRJ*u;u'*JRJ,u'*JRJ*u];
        urhs=[J'*(y+me)/sigma^2-JRJ*h_uc;u'*J'*(y+me)/sigma^2-u'*JRJ*h_uc];
        % matrix related to the Lagrange multipliers
        Lmat=zeros(n_h+1,nL);
        Lrhs=zeros(nL,1);
        for j=1:nL
            Lmat(hL(j),j)=1;
            Lmat(n_h+1,j)=1;
            Lrhs(j)=-h_uc(hL(j));
        end
        mat=[umat,Lmat;Lmat',zeros(nL)];
        rhs=[urhs;Lrhs];
        a=diag(mat);a(n_h+2:end)=1;
        warning off;imat=inv(diag(a.^-1)*mat)*diag(a.^-1);warning on;
        sol=imat*rhs;
        h=sol(1:n_h)+sol(n_h+1)+h_uc;
        h(hL)=0;
        nu=sol(n_h+2:end);
        sim=J*h;
        event1=sprintf('iteration %i: number of Lagrange multipliers %i',[iter,nL]);
       all_lines=cellstr(get(handles.logfile_listbox,'String'));
       add_line = [all_lines;event1];
       set(handles.logfile_listbox,'String',add_line) 
       set(handles.logfile_listbox,'ListboxTop',length(add_line)-2) 
       fid=fopen('log.log','a');
       fprintf(fid,[event1 ' \r\n']);
       fclose(fid);
       set(handles.int_res_uipanel, 'Title', sprintf('Realization %i',ireal))
       handle=plot(handles.axes1,t,y+me,'-r',t,sim,'-k');
       set(handle(1),'markersize',2);
       t_tick=linspace(t(1),t(end),6);
       set(handles.axes1,'XTick',t_tick);
       if     handles.timeformat~='n'
%        set(handles.axes1,'xticklabel',datestr(t_tick,'mmm-yyyy'));
       datetick(handles.axes1,'x');
       end
       legend(handles.axes1,'meas.','sim.');
       set(handles.textoutafter, 'String', sprintf('Output after iteration %i',iter));
       plot(handles.axes2,[0:n_h-1]*dt,h,'k');
       set(handles.texttransferafter, 'String', sprintf('Transfer function after iteration %i',iter));
       xlabel(handles.axes2,'\tau [d]');
       drawnow
        hLold=hL;
        % set of entries that need Lagrange multiplier
        hLadd=ii(h<0);
        % remove entries that don't need a Lagrange multiplier anymore
        hLrem=hL(nu>0);
        hL=hL(~ismember(hL,hLrem));
        hL=union(hL,hLadd);
        if (isempty(hL)), hL=1; elseif(hL(1)~=1), hL=[1;hL]; end
        nL=length(hL);
        if isempty(setdiff(hLold,hL)) && isempty(setdiff(hL,hLold)), break, end
    end    
    % plot realization
    t_h=dt*[0:n_h-1]';
    h_all(:,ireal) = h;
    set(handles.axes3, 'NextPlot', 'replace');
    hand=plot(handles.axes3,t_h,mean(h_all(:,1:ireal),2),'r');
    set(hand,'linewidth',1.5);
    xlabel(handles.axes3,'\tau [d]');
    set(handles.axes3, 'NextPlot', 'add');
    plot(handles.axes3,t_h,prctile(h_all(:,1:ireal),[10 90],2),'b');
    plot(handles.axes3,t_h,[min(h_all(:,1:ireal),[],2),max(h_all(:,1:ireal),[],2)],'b:');
    legend(handles.axes3,'mean','10%','90%','min','max')
end
stopflag = get(handles.StopMenuItem,'UserData');
if stopflag==1,   break,     end
theta_old=theta;
theta=exp(fminsearch(@(lntheta) sumprob(h_all,nreal,n_h,lntheta,dt),log(theta)));
event1=sprintf('Theta: %d;',theta);
       all_lines=cellstr(get(handles.logfile_listbox,'String'));
       add_line = [all_lines;event1];
       set(handles.logfile_listbox,'String',add_line) 
       set(handles.logfile_listbox,'ListboxTop',length(add_line)-2) 
       set(handles.slope_lin_var_value_edit,'string',theta);
       fid=fopen('log.log','a');
       fprintf(fid,[event1 ' \r\n']);
       fclose(fid);
h=h_be;
end
handles.TrFunc=h_be; %save transfer function b.e.
guidata(hObject,handles);
handles.Time_out=t_h; %save time
guidata(hObject,handles);
handles.TrFunc_mean=mean(h_all(:,1:nreal),2);
handles.TrFunc_all=h_all;
handles.TrFunc_quantiles=prctile(h_all,10,2);
handles.TrFunc_min=min(h_all,[],2);
handles.TrFunc_max=max(h_all,[],2);
guidata(hObject,handles);
% plot final results
set(handles.axes3, 'NextPlot', 'replace');
hand=plot(handles.axes3,t_h,mean(h_all,2),'r');
xlabel(handles.axes3,'\tau [d]');
ylabel(handles.axes3,'g [1/d]');
set(handles.axes3, 'NextPlot', 'add');
plot(handles.axes3,t_h,prctile(h_all,10,2),'b');
plot(handles.axes3,t_h,min(h_all,[],2),'c');
cross=plot(handles.axes3,t_h(5:10:end),h(5:10:end),'rx');set(cross,'markersize',4);
plot(handles.axes3,t_h,prctile(h_all,90,2),'b');
plot(handles.axes3,t_h,max(h_all,[],2),'c');
legend(handles.axes3,'conditional mean','10%, 90%','min, max','best estimate');
defaultBackground = get(0,'defaultUicontrolBackgroundColor');
set(handles.figure1,'Color',defaultBackground )
 end
end


function lnpsum = sumprob(h_all,nreal,n_h,lntheta,dt)
% probability of h according to prior statistics
theta=exp(lntheta);
lnpsum=0;
for ireal=1:nreal
    nnz=sum(h_all(:,ireal)>0);
    ng =size(h_all,1);
    nz = ng-nnz;
    lnp_i= -nnz/2*log(4*pi*theta)-(ng-1)/2*log(dt);
    % loop over all zero entries
    im=1; while (h_all(im,ireal)>0), im=im+1;end
    ip=im;
    for jj=1:nz-1
        % determine next entry
        ip=ip+1;while (h_all(ip,ireal)>0), ip=ip+1;end
    end
    % loop over all entries
    for jj=1:ng-1
        lnp_i = lnp_i - (h_all(jj+1,ireal)-h_all(jj,ireal))^2/(4*theta*dt);
    end
    lnpsum=lnpsum-lnp_i;
end


% --------------------------------------------------------------------
function OptionsMenuItem_Callback(hObject, eventdata, handles)
% hObject    handle to OptionsMenuItem (see GCBO)
% eventdata  reserved - to be defined in a future version of MATLAB
% handles    structure with handles and user data (see GUIDATA)

if any(strcmp('type_estimate',fieldnames(handles))) 
handles.type_estimate=SpecifCalcOpt(handles.type_estimate);
guidata(hObject,handles);
else
handles.type_estimate=SpecifCalcOpt('sm');
guidata(hObject,handles);
end
switch handles.type_estimate
  case  'sm' 
set(handles.type_est_value_edit,'string','Smooth estimate');
case 'cr'
set(handles.type_est_value_edit,'string','Cond. realisations');
  case 'cr+'
set(handles.type_est_value_edit,'string','Cond. realis, theta estimate ');
end

% --------------------------------------------------------------------
function StopMenuItem_Callback(hObject, eventdata, handles)
% hObject    handle to StopMenuItem (see GCBO)
% eventdata  reserved - to be defined in a future version of MATLAB
% handles    structure with handles and user data (see GUIDATA)
stopflag = 1;
set(hObject,'UserData',stopflag);  


% --------------------------------------------------------------------
function ParametersMenuItem_Callback(hObject, eventdata, handles)
% hObject    handle to ParametersMenuItem (see GCBO)
% eventdata  reserved - to be defined in a future version of MATLAB
% handles    structure with handles and user data (see GUIDATA)
if any(strcmp('Theta',fieldnames(handles))) & any(strcmp('Nreal',fieldnames(handles)))...
          & any(strcmp('TrFunLength',fieldnames(handles))) & any(strcmp('sigma',fieldnames(handles)))
[handles.Theta,handles.TrFunLength,handles.Nreal,handles.sigma]=SpecifParam(handles.Theta,handles.TrFunLength,handles.Nreal,handles.sigma);
else
[handles.Theta,handles.TrFunLength,handles.Nreal,handles.sigma]=SpecifParam('','','','');
end

guidata(hObject,handles);
set(handles.slope_lin_var_value_edit,'string',handles.Theta);
set(handles.length_tr_f_value_edit,'string',handles.TrFunLength);
set(handles.num_real_value_edit,'string',handles.Nreal);
set(handles.std_dev_ep_value_edit,'string',handles.sigma);
guidata(hObject,handles);



% --------------------------------------------------------------------
function QuitMenuItem_Callback(hObject, eventdata, handles)
% hObject    handle to QuitMenuItem (see GCBO)
% eventdata  reserved - to be defined in a future version of MATLAB
% handles    structure with handles and user data (see GUIDATA)

close(gcbf)
%closereq


% --------------------------------------------------------------------
function StartCalculationMenuItem_Callback(hObject, eventdata, handles)
% hObject    handle to StartCalculationMenuItem (see GCBO)
% eventdata  reserved - to be defined in a future version of MATLAB
% handles    structure with handles and user data (see GUIDATA)
calculate_button_Callback(hObject, eventdata, handles)

 
% --- Executes during object creation, after setting all properties.
function logfile_listbox_CreateFcn(hObject, eventdata, handles)
% hObject    handle to logfile_listbox (see GCBO)
% eventdata  reserved - to be defined in a future version of MATLAB
% handles    empty - handles not created until after all CreateFcns called

% Hint: listbox controls usually have a white background on Windows.
%       See ISPC and COMPUTER.
if ispc && isequal(get(hObject,'BackgroundColor'), get(0,'defaultUicontrolBackgroundColor'))
    set(hObject,'BackgroundColor','white');
end

% --------------------------------------------------------------------
function SpecifPathMenuItem_Callback(hObject, eventdata, handles)
% hObject    handle to SpecifPathMenuItem (see GCBO)
% eventdata  reserved - to be defined in a future version of MATLAB
% handles    structure with handles and user data (see GUIDATA)
if any(strcmp('timepath',fieldnames(handles))) 
     t=handles.timepath;
else t='';
end
if any(strcmp('inputpath',fieldnames(handles)))
     in=handles.inputpath;
else in='';
end
if any(strcmp('outputpath',fieldnames(handles)))
     out=handles.outputpath;
else out='';
end
if any(strcmp('initialtime',fieldnames(handles)))
     ini=handles.initialtime;
else ini='';
end
if  any(strcmp('timestep',fieldnames(handles)))
     step=handles.timestep;
else step='';
end
[handles.timepath,handles.inputpath,handles.outputpath,initialtime,timestep]=SpecifPath(t,in,out,ini,step);
guidata(hObject,handles);
if ischar(handles.timepath)&& ischar(handles.inputpath) && ischar(handles.outputpath)
currentFolder=pwd;
%load input signal
[pathname,file,ext]=fileparts(handles.inputpath);
cd(pathname);
handles.InpSig=load([file ext]);
guidata(hObject,handles);
%load output signal
[pathname,file,ext]=fileparts(handles.outputpath);
cd(pathname);
handles.OutSig=load([file ext]);
guidata(hObject,handles);
n=max([length(handles.InpSig),length(handles.OutSig)]);
guidata(hObject,handles);
if strmatch('not specified', handles.timepath)
handles.initialtime=str2double(initialtime);
guidata(hObject,handles);
handles.timestep=str2double(timestep);
guidata(hObject,handles);
handles.Time=[handles.initialtime:handles.timestep:handles.timestep*n];
guidata(hObject,handles);
else
%load time vector
[pathname,file,ext]=fileparts(handles.timepath);
cd(pathname);
handles.Time=load([file ext]);
guidata(hObject,handles);
handles.initialtime=handles.Time(1);
guidata(hObject,handles);
handles.timestep=handles.Time(2)-handles.Time(1);
guidata(hObject,handles);
end
%return to working folder
cd(currentFolder);
s=['Number of measurements '  num2str(length(handles.InpSig))];
add_line = char(datestr(now),handles.timepath,handles.inputpath,handles.outputpath,s);
       set(handles.logfile_listbox,'String',add_line) 
end



% --- Executes on button press in stopbutton.
function stopbutton_Callback(hObject, eventdata, handles)
% hObject    handle to stopbutton (see GCBO)
% eventdata  reserved - to be defined in a future version of MATLAB
% handles    structure with handles and user data (see GUIDATA)
stopflag = 1;
set(handles.StopMenuItem,'UserData',stopflag);
StopMenuItem_Callback(hObject, eventdata, handles)

% --------------------------------------------------------------------
function ViewSignalMenuItem_Callback(hObject, eventdata, handles)
% hObject    handle to ViewSignalMenuItem (see GCBO)
% eventdata  reserved - to be defined in a future version of MATLAB
% handles    structure with handles and user data (see GUIDATA)
SpecifViewSignal(handles.Time,handles.InpSig,handles.OutSig);

% --------------------------------------------------------------------
function InOutTPropMenuItem_Callback(hObject, eventdata, handles)
% hObject    handle to InOutTPropMenuItem (see GCBO)
% eventdata  reserved - to be defined in a future version of MATLAB
% handles    structure with handles and user data (see GUIDATA)
[handles.timeformat,handles.timeunits,handles.IniConc,handles.MeanInOut]=SpecifInOutTProp(handles.timeformat,handles.timeunits,handles.IniConc,handles.MeanInOut);
guidata(hObject,handles);


% --------------------------------------------------------------------
function TrFuncMeanSaveMenuItem_Callback(hObject, eventdata, handles)
% hObject    handle to TrFuncMeanSaveMenuItem (see GCBO)
% eventdata  reserved - to be defined in a future version of MATLAB
% handles    structure with handles and user data (see GUIDATA)
currentFolder = pwd;
[filename,pathname] = uiputfile({'*.txt';'*.mat'},'Save transfer function');
[~,file,ext]=fileparts(filename);
cd(pathname);
if strcmp(ext,'.txt') 
     fid = fopen(filename,'w');
fprintf(fid,'%17s%17s%17s\n','t','g(t)_sm_est','g(t)_mean');
fid = fopen(filename,'a');
for i=[1:length(handles.TrFunc)]
    fprintf(fid,'%14.3g %14.3g %14.3g\n',...
    handles.Time_out(i),...
    handles.TrFunc(i),...
    handles.TrFunc_mean(i));
end
fclose('all');
elseif strcmp(ext,'.mat') 
     t=handles.Time_out;
     TrFunc_mean=handles.TrFunc_mean;
     TrFunc_sm_est=handles.TrFunc;
     save(filename,'t','TrFunc_sm_est','TrFunc_mean');
end
cd(currentFolder);



% --------------------------------------------------------------------
function TrFuncQuantilesSaveMenuItem_Callback(hObject, eventdata, handles)
% hObject    handle to TrFuncQuantilesSaveMenuItem (see GCBO)
% eventdata  reserved - to be defined in a future version of MATLAB
% handles    structure with handles and user data (see GUIDATA)
currentFolder = pwd;
TrFunc_quantile10=prctile(handles.TrFunc,10,2);
TrFunc_quantile90=prctile(handles.TrFunc,90,2);
TrFunc_median=prctile(handles.TrFunc,50,2);
[filename,pathname] = uiputfile({'*.txt';'*.mat'},'Save transfer function');
[~,file,ext]=fileparts(filename);
cd(pathname);
if strcmp(ext,'.txt') 
     fid = fopen(filename,'w');
fprintf(fid,'%17s%17s%17s%17s%17s\n','t','g(tau)_10%','g(tau)_50%',...
    'g(tau)_90%','g(tau)_sm_est');
fid = fopen(filename,'a');
for i=[1:length(handles.TrFunc)]
fprintf(fid,'%14.3g %14.3g %14.3g %14.3g %14.3g\n', ...
     handles.Time_out(i),...
     TrFunc_quantile10(i),...
     TrFunc_median(i),...
     TrFunc_quantile90(i),...
     handles.TrFunc(i));
end
fclose('all');
elseif strcmp(ext,'.mat') 
     t=handles.Time_out;
     TrFunc_sm_est=handles.TrFunc;
     save(filename,'t','TrFunc_sm_est','TrFunc_quantile10',...
                   'TrFunc_quantile90','TrFunc_median');
end
cd(currentFolder);



% --------------------------------------------------------------------
function TrFuncAllSaveMenuItem_Callback(hObject, eventdata, handles)
% hObject    handle to TrFuncAllSaveMenuItem (see GCBO)
% eventdata  reserved - to be defined in a future version of MATLAB
% handles    structure with handles and user data (see GUIDATA)
currentFolder = pwd;
[filename,pathname] = uiputfile({'*.txt';'*.mat'},'Save transfer function');
[~,file,ext]=fileparts(filename);
cd(pathname);
if strcmp(ext,'.txt') 
     fid = fopen(filename,'w');
fprintf(fid,'%17s%17s','t','g(tau)_1real');
for i=2:handles.Nreal
     fprintf(fid,'%9s%u%4s','g(tau)_',i,'real');
end
fprintf(fid,'\n');
fid = fopen(filename,'a');
for i=[1:size(handles.TrFunc_all,1)]
     for j=[1:size(handles.TrFunc_all,2)]
          if j==1
               fprintf(fid,'%14.3g', handles.Time_out(i));
          end
     fprintf(fid,'%14.3g', handles.TrFunc_all(i,j));
     if j==size(handles.TrFunc_all,2)
          fprintf(fid,'\n');
     end
     end
end
fclose('all');
elseif strcmp(ext,'.mat') 
     t=handles.Time_out;
     TrFunc_sm_est=handles.TrFunc;
     TrFunc_all_real=handles.TrFunc_all;
     save(filename,'t','TrFunc_sm_est','TrFunc_all_real');
end
cd(currentFolder);





% --------------------------------------------------------------------
function parameters_uipanel_ButtonDownFcn(hObject, eventdata, handles)
% hObject    handle to parameters_uipanel (see GCBO)
% eventdata  reserved - to be defined in a future version of MATLAB
% handles    structure with handles and user data (see GUIDATA)
ParametersMenuItem_Callback(hObject, eventdata, handles)


% --- If Enable == 'on', executes on mouse press in 5 pixel border.
% --- Otherwise, executes on mouse press in 5 pixel border or over slope_lin_var_value_edit.
function slope_lin_var_value_edit_ButtonDownFcn(hObject, eventdata, handles)
% hObject    handle to slope_lin_var_value_edit (see GCBO)
% eventdata  reserved - to be defined in a future version of MATLAB
% handles    structure with handles and user data (see GUIDATA)
ParametersMenuItem_Callback(hObject, eventdata, handles)


% --- If Enable == 'on', executes on mouse press in 5 pixel border.
% --- Otherwise, executes on mouse press in 5 pixel border or over slope_lin_var_edit.
function slope_lin_var_edit_ButtonDownFcn(hObject, eventdata, handles)
% hObject    handle to slope_lin_var_edit (see GCBO)
% eventdata  reserved - to be defined in a future version of MATLAB
% handles    structure with handles and user data (see GUIDATA)
ParametersMenuItem_Callback(hObject, eventdata, handles)


% --- If Enable == 'on', executes on mouse press in 5 pixel border.
% --- Otherwise, executes on mouse press in 5 pixel border or over tp_est_edit.
function tp_est_edit_ButtonDownFcn(hObject, eventdata, handles)
% hObject    handle to tp_est_edit (see GCBO)
% eventdata  reserved - to be defined in a future version of MATLAB
% handles    structure with handles and user data (see GUIDATA)
OptionsMenuItem_Callback(hObject, eventdata, handles)


% --------------------------------------------------------------------
function ModelOutcomeSaveMenuItem_Callback(hObject, eventdata, handles)
% hObject    handle to ModelOutcomeSaveMenuItem (see GCBO)
% eventdata  reserved - to be defined in a future version of MATLAB
% handles    structure with handles and user data (see GUIDATA)
currentFolder = pwd;
[filename,pathname] = uiputfile({'*.txt';'*.mat'},'Save model outcome');
[~,file,ext]=fileparts(filename);
cd(pathname);
if strcmp(ext,'.txt') 
     fid = fopen(filename,'w');
fprintf(fid,'%17s%17s%17s\n','t','Output_meas','Output_sim');
fid = fopen(filename,'a');
for i=[1:min(length(handles.output_meas),length(handles.output_sim))]
fprintf(fid,'%14.3g %14.3g %14.3g\n',handles.output_time(i),handles.output_meas(i),handles.output_sim(i));
end
fclose('all');
elseif strcmp(ext,'.mat') 
     t=handles.output_time;
     Output_meas=handles.output_meas;
     Output_sim=handles.output_sim;
     save(filename,'t','Output_meas','Output_sim');
end
cd(currentFolder);
